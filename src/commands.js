import { EmbedBuilder, SlashCommandBuilder } from "discord.js";
import { Trait } from "./db.js";
import { userTraitsCache } from "./cache.js";
import { generateTraitsPrompt, generateChatReply } from "./ai.js";
import { logger } from "./utils/logger.js";

const userMessages = new Map();
const userMessageCount = new Map();
const cooldowns = new Map();
const COOLDOWN_SECONDS = 5;

export async function handleMessage(message) {
  if (!message.guild || message.author.bot) return;

  const now = Date.now();
  const channelKey = `${message.guild.id}-${message.channel.id}`;
  if (now < (cooldowns.get(channelKey) || 0)) return;
  cooldowns.set(channelKey, now + COOLDOWN_SECONDS * 1000);

  const userId = message.author.id;
  const userName = message.author.username;

  let traitDoc = userTraitsCache.get(userId);
  if (!traitDoc) {
    const dbDoc = await Trait.findById(userId).lean();
    userTraitsCache.set(userId, dbDoc || { trait_summary: "None yet." });
    traitDoc = userTraitsCache.get(userId);
  }

  if (!userMessages.has(userId)) userMessages.set(userId, []);
  const messages = userMessages.get(userId);
  messages.push(message.content);
  if (messages.length > 50) messages.shift();

  const count = (userMessageCount.get(userId) || 0) + 1;
  userMessageCount.set(userId, count);

  if (count % 10 === 0) {
    try {
      const result = await generateTraitsPrompt(
        userName,
        traitDoc.trait_summary,
        messages
      );
      const newSummary =
        result?.response && typeof result.response.text === "function"
          ? result.response.text().trim()
          : null;
      if (newSummary) {
        traitDoc.trait_summary = newSummary;
        userTraitsCache.set(userId, traitDoc);
        await Trait.findByIdAndUpdate(userId, { trait_summary: newSummary });
        logger.db("Updated and synced trait summary for", userName);
      } else {
        logger.warn("Trait generation returned an invalid response structure.");
      }
    } catch (err) {
      logger.err("Trait generation failed:", err.message);
    }
  }

  try {
    const history = await message.channel.messages.fetch({ limit: 13 });
    const chatHistory = [...history.values()]
      .reverse()
      .map((m) => `${m.author.username}: ${m.content}`)
      .join("\n");

    // Send typing indicator
    await message.channel.sendTyping();

    const replyResult = await generateChatReply(
      chatHistory,
      traitDoc.trait_summary,
      message.content,
      message.author
    );
    await message.channel.send(replyResult.response.text());
    // logger.ai("Chat response to", userName);
  } catch (err) {
    logger.err("Chat reply generation failed:", err.message);
  }
}

export const commands = [
  new SlashCommandBuilder()
    .setName("hello")
    .setDescription("Replies with a greeting."),
  new SlashCommandBuilder()
    .setName("traits")
    .setDescription("Displays your trait profile."),
].map((command) => command.toJSON());

export async function handleInteraction(interaction) {
  if (!interaction.isChatInputCommand()) return;

  if (interaction.commandName === "hello") {
    await interaction.reply("Greetings, mortal.");
  }

  if (interaction.commandName === "traits") {
    const userId = interaction.user.id;
    let traitDoc = userTraitsCache.get(userId);
    if (!traitDoc) {
      traitDoc = await Trait.findById(userId);
      if (traitDoc) userTraitsCache.set(userId, traitDoc);
    }

    if (
      !traitDoc ||
      !traitDoc.trait_summary ||
      traitDoc.trait_summary === "None yet."
    ) {
      await interaction.reply(
        "I haven't figured you out yet... Send more messages and give me time."
      );
    } else {
      const embed = new EmbedBuilder()
        .setTitle(`${interaction.user.username}'s Trait Profile`)
        .setDescription(traitDoc.trait_summary)
        .setColor("Purple")
        .setFooter({ text: "Generated by your lovely local AI stalker ðŸ¤–" });
      try {
        await interaction.reply({ embeds: [embed] });
      } catch (err) {
        logger.err("Failed to send traits embed: ", err.message);
      }
    }
  }
}
